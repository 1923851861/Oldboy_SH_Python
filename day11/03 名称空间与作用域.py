'''


1、名称空间namespaces
    存放名字与值绑定关系的地方

2、名称空间分为三大类
    内置名称空间：
        作用：存放python解释器自带的名字
        生命周期：
            在解释器启动时生效，在解释器关闭时失效

    全局名称空间：
        作用：除了内置的与局部的名字外，其余都是全局名字
        生命周期：
            在文件执行时生效，在文件执行完毕时失效

        例如：x，func，y，l，z都是
            x=1
            def func():
                a=1

            y=2
            l=[1,2]

            if 3 > 2:
                if
                    if
                        if
                            z=3
    局部名称空间：
        作用：用于存放函数调用期间函数体产生的名字
        生命周期：
            在文件执行过程
            如果调用了某个函数才会临时生效，在函数执行完毕后失效

    三种名称空间的加载顺序是：
        内置-》全局-》局部

    名称空间就是用来存放名字与值的绑定关系的，所以但凡要查找名字
    一定是从三者之一找到，查找顺序:
        从当前所在的位置倒着查找，如果当前所在的位置是局部名称空间，
        则查找顺序是：
            局部-》全局-》内置

3、作用域：
    域指的是区域、范围，作用域即作用的范围

    全局作用范围，全局作用域（内置名称空间与全局名称空间）
        全局有效，全局存活
    局部作用范围，局部作用域（局部名称空间）
        局部有效，临时存活

'''

# x=1
# # len=100
# def func():
#     y=2
#     len=1000
#     # print(len)
#     print(a)
# func()

# print(len)


# def func():
#     y=2
#     print(x)
#
# x=1
# func()
#
# x=10

# x=1
# def f1():
#     def f2():
#         def f3():
#             zzz=333
#             print(x)
#         # x = 22222
#         f3()
#     # x=111111
#     f2()
#
# def bar():
#     print(x)
#
# f1()
# bar()


# 作用域关系是在函数定义阶段就固定死了，但凡调用函数都需要跑到定义阶段去找作用域关系
# x=1
# def f1():
#     print(x)
#
# # f1()
# x=1000000000000000000000000000000000000000000000000000000000000000
# def f2():
#     # print(f1)
#     x=11111111111111111111111111111
#     f1()
#
# f2()



#函数对象+作用域：******
# def f1():
#     x=1
#     def inner():
#         print('from inner',x)
#     return inner
#
# f=f1()
#
# # print(f)
#
# def bar():
#     x=111111111111111111111111111111111111111111111
#     f()
#
# bar()


#
# x=1
# def foo():
#     global x
#     x=2
#
# foo()
# print(x)



# x=1
# def f1():
#     def f2():
#         x=22222222
#         def f3():
#             global x
#             x=11111111111111111
#         f3()
#     f2()
#
# f1()
# print(x)


# x=1
# def f1():
#     # x=33333
#     def f2():
#         # x=22222222
#         def f3():
#             nonlocal x
#             x=20000000000
#         f3()
#         print(x)
#     f2()
#
# f1()
# print(x)



# 在局部如果想要修改全局的可变类型，不需要借助任何声明，可以直接修改
# 在局部如果想要修改全局的不可变类型，需要借助global声明，声明为全局的变量就可以直接修改了

# x=[]
# def f1():
#     x.append(1)
# f1()
# f1()
# print(x)


